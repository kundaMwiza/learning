#include <iostream>
#include <vector>
#include <random>
#include <algorithm>
#include <numeric>

int main(int argc, const char *argv[])
{

    // lambda expressions
    // a convenient way of defining an anonymous function
    // object (a closure ~ an environment which has an enclosing environment)
    // at the very least, the enclosing environment is the global environment.
    // different parts of a lambda function
    // 1 [] what to capture from the parent environment and how
    // 2 () syntax for specifying function parameters (optional)
    // 3 mutable whether it can modify objects passed by value in the parent environment (optional)
    // 4 throw() exception specification (optional)
    // 5 trailing return type, by default the return type of auto deduced (optional)
    // 6 lambda body

    // a lambda can introduce new variables in its body (C++14),
    // and it can also capture or access variables from the surrounding scope
    // can specify whether the capture is by reference or by value.
    // [&] capture all variables in the parent by reference
    // [=] capture all variables in the parent by value
    // [] do not capture any variables in the enclosing scope
    // can also use a default capture mode, alongside specific ways of
    // capturing some variables:
    // [&, factor] -> capture all variables by reference, except factor
    // which is captured by value
    // however, it is an error to do [&, &factor], or [=, factor]
    // one thing to note is that the capture clause for a lambda function
    // refers to automatic objects. static objects can be used within
    // lambda functions without being captured.
    // static objects are objects that are allocated at compile time and exist
    // throughout the entire execution of the program

    // without using a lambda function

    // in order to generate random values according to a distribution in c++
    // firstly need to create an instance of a random device
    // this is used to generate a seed number to be used by a generating engine
    // a generating engine such as mt19937 at construction can take in
    // this random seed
    // the generating engine will return a random value each time it is called
    // however, if we are interested in generating values from a particular
    // distribution, e.g. a uniform distribution between (a,b)
    // we can use the values generated by the generating engine to return
    // values that are constrained to be in the interval (a,b)
    std::random_device rnd_device;
    std::mt19937 mersene_engine(rnd_device());

    std::uniform_int_distribution<int> dist(0, 1000);

    std::vector<int> example_vector(2000, 0);

    std::generate(
        example_vector.begin(), example_vector.end(),
        [&dist, &mersene_engine]()
        { return dist(mersene_engine); });

    // write output

    for (auto &elem : example_vector)
    {

        std::cout << "value:"
                  << elem
                  << std::endl;
    }

    // note that for lambda functions, the capture list is only for
    // NON LOCAL
    // NON STATIC objects
    // static objects and variables in the outer parent enclosure care captured
    // by default

    // also note that if a lambda functions uses other keywords apart from return
    // eg using for statements or while statements, the lambda expressions assumes the
    // return type to void. In this case, the return type needs to be explicitly
    // defined by using a trailing return type
    // for example

    // this is assumed to return void becasue we are using an if statemet
    auto f = [](const int val)
    {
        if (val < 2)
            return val;
        else
            return val * 2;
    }
    // the modification to the above statement is:
    auto f = [](const int val) -> int
    {
        if (val < 2)
            return val;
        else
            return val * 2;
    }
    // in this way, the return type is an integer

    // the capture list of a lambda expression can only consist of local non static variables
    // from the enclosing function
    // if the objects are captured by value, in order to modify them in the lambda expression
    // the mutable keyword must be used in the definition of the lambda expression
    // just like with const member functions: the data members that can be modified in such
    // functions need to be declared as mutable
    // however for references, do not need to do this as whether the object can be modified or not
    // depends on the type of referene e.g. const or not
    return 0;
}